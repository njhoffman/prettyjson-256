{"version":3,"sources":["../lib/parser.js"],"names":["Utils","require","isError","isFunction","isArray","isString","isDate","isObjectLike","isEmpty","isNumber","each","keys","getOptions","getPrintColor","options","pColor","_addColorToData","input","sInput","string","number","boolTrue","boolFalse","empty","Date","date","join","_indentMultiLine","spaces","split","map","indent","line","_handleMultiLine","data","indentation","defaultIndentation","_handleFunction","funcHeader","toString","replace","functionTag","functionHeader","_handleError","errorDivider","errorName","name","errorMessage","message","errorStack","stack","_handleArray","level","arrayOut","depth","length","push","element","i","numberArrays","dash","parse","trim","_handleObject","maxIndexLength","getMaxIndexLength","key","objOut","isSerializable","showEmpty","_handleEmpty","emptyArrayMsg","emptyStringMsg","emptyObjectMsg","_handleSerializable","isCustomColor","customColors","colorKey","output","concat","module","exports"],"mappings":"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","file":"parser.js","sourcesContent":["const Utils = require('./utils');\nconst {\n  isError,\n  isFunction,\n  isArray,\n  isString,\n  isDate,\n  isObjectLike,\n  isEmpty,\n  isNumber,\n  each,\n  keys\n} = require('lodash');\n\nconst { getOptions, getPrintColor } = require('./settings');\nlet options = getOptions();\nlet pColor = getPrintColor();\n\nconst _addColorToData = (input) => {\n  let sInput = input + '';\n\n  /* eslint-disable no-multi-spaces */\n  if (isString(input))       { return pColor.string(input); }\n  if (isNumber(input))       { return pColor.number(input); }\n  if (input === true)        { return pColor.boolTrue(sInput); }\n  if (input === false)       { return pColor.boolFalse(sInput); }\n  if (input === null)        { return pColor.empty(sInput); }\n  if (input instanceof Date) { return pColor.date(sInput); }\n  if (isArray(input))        { return input.join(', '); }\n  /* eslint-enable no-multi-spaces */\n\n  return sInput;\n};\n\nconst _indentMultiLine = (string, spaces) => {\n  return string\n    .split('\\n')\n    .map(line => (Utils.indent(spaces) + line))\n    .join('\\n');\n};\n\nconst _handleMultiLine = (data, indentation) => {\n  return [\n    Utils.indent(indentation) + '\"\"\"',\n    _indentMultiLine(data, indentation + options.defaultIndentation),\n    Utils.indent(indentation) + '\"\"\"'\n  ];\n};\n\nconst _handleFunction = (data, indentation) => {\n  const funcHeader = data.toString().split('\\n')[0].replace('{', '');\n  return [\n    Utils.indent(indentation) +\n    pColor.functionTag('[Function] ') +\n    pColor.functionHeader(funcHeader)\n  ];\n};\n\nconst _handleError = (data, indentation) => {\n  const funcHeader = data.toString().split('\\n')[0].replace('{', '');\n  return [\n    pColor.errorDivider(options.errorDivider) + '\\n' +\n    pColor.errorName(data.name) + '\\n' +\n    pColor.errorMessage(data.message) + '\\n' +\n    pColor.errorStack(data.stack) + '\\n' +\n    pColor.errorDivider(options.errorDivider)\n  ];\n};\n\nconst _handleArray = (data, indentation, level) => {\n  let arrayOut = [];\n  if (level + 1 === options.depth) {\n    let line = Utils.indent(indentation) + pColor.depth(`[Array length ${data.length}]`);\n    arrayOut.push(line);\n  } else {\n    level++;\n    each(data, function (element, i) {\n      let line = options.numberArrays ? `-[${i}] ` : '- ';\n      line = Utils.indent(indentation) + pColor.dash(line);\n      // if arrays are numbered, each element should be on its own line\n      if (options.numberArrays) {\n        arrayOut.push(line);\n        line = Utils.indent(indentation + options.defaultIndentation);\n      }\n      line += parse(\n        element,\n        indentation + options.defaultIndentation,\n        level\n      ).trim();\n      arrayOut.push(line);\n    });\n  }\n  return arrayOut;\n};\n\nconst _handleObject = (data, indentation, level) => {\n  // Get the size of the longest index to align all the values\n  var maxIndexLength = Utils.getMaxIndexLength(data);\n  var key;\n\n  var objOut = [];\n  level++;\n  each(keys(data), (i) => {\n    const element = data[i];\n    key = (i + ': ');\n    key = Utils.indent(indentation) + pColor.keys(key);\n\n    // If the value is serializable, render it on the same line\n    if (Utils.isSerializable(element, options)) {\n        // but don't render anything if showEmpty setting is false and data is empty array, object, or string\n      if (!((isObjectLike(element) || isString(element)) && isEmpty(element) && !options.showEmpty)) {\n        key += parse(element, maxIndexLength - i.length);\n        objOut.push(key);\n      }\n    } else if (level === options.depth) {\n      // dont nest any more for object if depth level reached\n      key += Utils.indent(maxIndexLength - i.length) +\n        pColor.depth(`[Object] (${keys(element).length}  keys)`);\n      objOut.push(key);\n    } else if (level + 1 === options.depth && isArray(element)) {\n      key += Utils.indent(maxIndexLength - i.length) +\n        pColor.depth(`[Array length ${keys(element).length}]`);\n      objOut.push(key);\n    } else {\n      // If the index is an array or object, render it in next line\n      objOut.push(key);\n      objOut.push(\n        parse(\n          element,\n          indentation + options.defaultIndentation,\n          level\n        )\n      );\n    }\n  });\n  return objOut;\n};\n\nconst _handleEmpty = (data, indentation) => {\n  if (isArray(data)) {\n    return Utils.indent(indentation) + pColor.empty(options.emptyArrayMsg);\n  } else if (isString(data)) {\n    return Utils.indent(indentation) + pColor.empty(options.emptyStringMsg);\n  } else if (isObjectLike(data)) {\n    return Utils.indent(indentation) + pColor.empty(options.emptyObjectMsg);\n  }\n};\n\nconst _handleSerializable = (data, indentation) => {\n  if (Utils.isCustomColor(data, options.customColors)) {\n    const colorKey = keys(data)[0];\n    return Utils.indent(indentation) + pColor[colorKey](data[colorKey]);\n  } else if (isFunction(data)) {\n    return _handleFunction(data, indentation);\n  } else if (isDate(data) || isNumber(data)) {\n    return Utils.indent(indentation) + _addColorToData(data);\n  } else if ((isObjectLike(data) || isString(data)) && isEmpty(data)) {\n    return _handleEmpty(data, indentation);\n  } else {\n    // Render a string exactly equal\n    return Utils.indent(indentation) + _addColorToData(data);\n  }\n};\n\nconst parse = (data, indentation = 0, level = 0) => {\n  let output = [];\n  options = getOptions();\n  pColor = getPrintColor();\n\n  if (Utils.isSerializable(data, options)) {\n    output = output.concat(_handleSerializable(data, indentation));\n  } else if (isString(data)) {\n    // unserializable string means it's multiline\n    output = output.concat(_handleMultiLine(data, indentation));\n  } else if (isArray(data)) {\n    output = output.concat(_handleArray(data, indentation, level));\n  } else if (isError(data)) {\n    output = output.concat(_handleError(data, indentation, level));\n  } else if (isObjectLike(data)) {\n    output = output.concat(_handleObject(data, indentation, level));\n  }\n\n  // Return all the lines as a string\n  return output.join('\\n');\n};\n\nmodule.exports = parse;\n"]}