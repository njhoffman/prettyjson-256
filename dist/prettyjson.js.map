{"version":3,"sources":["../lib/prettyjson.js"],"names":["maxSortDepth","currSortDepth","_sortKeys","data","parentIsArray","sortedData","numberArrays","sort","key","push","init","customOptions","render","startIndent","alphabetizeKeys","renderString","output","parsedData","beginningOfJson","indexOf","string","substr","JSON","parse","e","error","exports"],"mappings":"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","file":"prettyjson.js","sourcesContent":["import { isArray, isObjectLike, each, isEmpty, isFunction, keys } from 'lodash';\nimport { options, pColor, init as settingsInit } from './settings';\nimport parse from './parser';\n\n// exports.version = require('../package.json').version;\n\nconst maxSortDepth = 20;\nlet currSortDepth = 0;\nconst _sortKeys = (data, parentIsArray) => {\n  let sortedData = parentIsArray && !options.numberArrays ? [] : {};\n  each(keys(data).sort(), (key) => {\n    // continue recursion if item is object and not exceeding maximum depth\n    if (isObjectLike(data[key]) && currSortDepth < maxSortDepth) {\n      currSortDepth++;\n      if (isArray(data[key])) {\n        sortedData[key] = _sortKeys(data[key], (!options.numberArrays));\n      } else {\n        sortedData[key] = _sortKeys(data[key]);\n      }\n    } else {\n      if (isArray(sortedData)) {\n        sortedData.push(data[key]);\n      } else {\n        sortedData[key] = data[key];\n      }\n    }\n  });\n  currSortDepth--;\n  return sortedData;\n};\n\nexport const init = (customOptions = {}) => {\n  settingsInit(customOptions);\n  return render;\n};\n\nexport const render = (data, startIndent = 0, customOptions = {}) => {\n  !isEmpty(customOptions) && settingsInit(customOptions);\n  if (options.alphabetizeKeys) {\n    data = _sortKeys(data, isArray(data));\n  }\n\n  return parse(data, startIndent);\n};\n\nexport const renderString = (data, customOptions) => {\n  // called from direct entry of cli\n  !isEmpty(customOptions) && settingsInit(customOptions);\n\n  let output = '';\n  let parsedData;\n\n  if (typeof data !== 'string' || data === '') {\n    return '';\n  }\n\n  if (data[0] !== '{' && data[0] !== '[') {\n    let beginningOfJson =\n      data.indexOf('{') === -1\n      ? data.indexOf('[')\n      : data.indexOf('[') === -1\n      ? data.indexOf('{')\n      : data.indexOf('{') < data.indexOf('[')\n      ? data.indexOf('{')\n      : data.indexOf('[');\n    output += pColor.string(data.substr(0, beginningOfJson)) + '\\n';\n    data = data.substr(beginningOfJson);\n  }\n\n  try {\n    parsedData = JSON.parse(data);\n  } catch (e) {\n    return pColor.error('Error:') + ' Not valid JSON!';\n  }\n\n  output += exports.render(parsedData);\n  return output;\n};\n"]}